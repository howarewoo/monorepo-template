import * as fs from "node:fs";
import * as path from "node:path";
import * as ts from "typescript";
import { formatTypeString, replaceAbsolutePaths } from "./gencode-utils";

const API_ROOT = path.resolve(import.meta.dirname, "..");
const ROUTER_FILE = path.join(API_ROOT, "src/router.ts");
const OUTPUT_DIR = path.resolve(
  API_ROOT,
  "../../packages/infrastructure/api-client/src/generated",
);
const OUTPUT_FILE = path.join(OUTPUT_DIR, "router-types.d.ts");

// Load tsconfig for the api project
const configPath = ts.findConfigFile(API_ROOT, ts.sys.fileExists, "tsconfig.json");
if (!configPath) {
  throw new Error("Could not find apps/api/tsconfig.json");
}
const configFile = ts.readConfigFile(configPath, ts.sys.readFile);
if (configFile.error) {
  const message = ts.flattenDiagnosticMessageText(configFile.error.messageText, "\n");
  throw new Error(`Failed to parse apps/api/tsconfig.json: ${message}`);
}
const parsedConfig = ts.parseJsonConfigFileContent(configFile.config, ts.sys, API_ROOT);

// Create TypeScript program and type checker
const program = ts.createProgram([ROUTER_FILE], parsedConfig.options);
const checker = program.getTypeChecker();
const sourceFile = program.getSourceFile(ROUTER_FILE);

if (!sourceFile) {
  throw new Error(`Could not load source file: ${ROUTER_FILE}`);
}

// Find the Router type export
const moduleSymbol = checker.getSymbolAtLocation(sourceFile);
if (!moduleSymbol) {
  throw new Error("Could not get module symbol for router.ts");
}

const exports = checker.getExportsOfModule(moduleSymbol);
const routerExport = exports.find((e) => e.getName() === "Router");
if (!routerExport) {
  throw new Error('Could not find "Router" export in router.ts');
}

// Resolve the type behind the Router alias
const routerType = checker.getDeclaredTypeOfSymbol(routerExport);

// Serialize to a fully-expanded type string with no truncation
const typeString = checker.typeToString(
  routerType,
  sourceFile,
  ts.TypeFormatFlags.NoTruncation |
    ts.TypeFormatFlags.MultilineObjectLiterals |
    ts.TypeFormatFlags.InTypeAlias,
);

const processedTypeString = formatTypeString(replaceAbsolutePaths(typeString));

// Validate: reject if the output references @features packages
if (processedTypeString.includes("@features/")) {
  throw new Error(
    "Generated type references @features/* — the type was not fully expanded. " +
      "This likely means a named type from a feature package leaked through. " +
      "Check that all feature types resolve to structural types.",
  );
}

// Write the generated file
fs.mkdirSync(OUTPUT_DIR, { recursive: true });

const header = [
  "// AUTO-GENERATED by apps/api gencode script — do not edit manually.",
  "// Run `pnpm gencode` from the repository root to regenerate.",
  "//",
  "// Generated from: apps/api/src/router.ts",
  "",
].join("\n");

const output = `${header}
export type Router = ${processedTypeString};
`;

fs.writeFileSync(OUTPUT_FILE, output);
console.log(`Generated: ${path.relative(path.resolve(API_ROOT, "../.."), OUTPUT_FILE)}`);
