import * as fs from "node:fs";
import * as path from "node:path";
import * as ts from "typescript";

const API_ROOT = path.resolve(import.meta.dirname, "..");
const ROUTER_FILE = path.join(API_ROOT, "src/router.ts");
const OUTPUT_DIR = path.resolve(
  API_ROOT,
  "../../packages/infrastructure/api-client/src/generated",
);
const OUTPUT_FILE = path.join(OUTPUT_DIR, "router-types.d.ts");

// Load tsconfig for the api project
const configPath = ts.findConfigFile(API_ROOT, ts.sys.fileExists, "tsconfig.json");
if (!configPath) {
  throw new Error("Could not find apps/api/tsconfig.json");
}
const configFile = ts.readConfigFile(configPath, ts.sys.readFile);
const parsedConfig = ts.parseJsonConfigFileContent(configFile.config, ts.sys, API_ROOT);

// Create TypeScript program and type checker
const program = ts.createProgram([ROUTER_FILE], parsedConfig.options);
const checker = program.getTypeChecker();
const sourceFile = program.getSourceFile(ROUTER_FILE);

if (!sourceFile) {
  throw new Error(`Could not load source file: ${ROUTER_FILE}`);
}

// Find the Router type export
const moduleSymbol = checker.getSymbolAtLocation(sourceFile);
if (!moduleSymbol) {
  throw new Error("Could not get module symbol for router.ts");
}

const exports = checker.getExportsOfModule(moduleSymbol);
const routerExport = exports.find((e) => e.getName() === "Router");
if (!routerExport) {
  throw new Error('Could not find "Router" export in router.ts');
}

// Resolve the type behind the Router alias
const routerType = checker.getDeclaredTypeOfSymbol(routerExport);

// Serialize to a fully-expanded type string with no truncation
const typeString = checker.typeToString(
  routerType,
  sourceFile,
  ts.TypeFormatFlags.NoTruncation |
    ts.TypeFormatFlags.MultilineObjectLiterals |
    ts.TypeFormatFlags.InTypeAlias,
);

// Post-process: replace absolute pnpm store paths with package specifiers
function replaceAbsolutePaths(typeStr: string): string {
  return typeStr.replace(
    /import\("([^"]+)"\)/g,
    (_match: string, importPath: string) => {
      const marker = "node_modules/";
      const lastIndex = importPath.lastIndexOf(marker);
      if (lastIndex === -1) return _match;

      const packagePath = importPath.substring(lastIndex + marker.length);

      // Extract package name (handle scoped @scope/name packages)
      let packageName: string;
      let subPath: string;

      if (packagePath.startsWith("@")) {
        const parts = packagePath.split("/");
        packageName = `${parts[0]}/${parts[1]}`;
        subPath = parts.slice(2).join("/");
      } else {
        const parts = packagePath.split("/");
        packageName = parts[0] as string;
        subPath = parts.slice(1).join("/");
      }

      // Strip common entry points — use bare package specifier
      if (
        !subPath ||
        subPath === "index" ||
        subPath === "dist/index" ||
        subPath === "src/index"
      ) {
        return `import("${packageName}")`;
      }

      return `import("${packageName}/${subPath}")`;
    },
  );
}

// Post-process: format the type string with indentation
function formatTypeString(typeStr: string): string {
  let result = "";
  let indent = 0;
  const INDENT = "  ";

  for (let i = 0; i < typeStr.length; i++) {
    const char = typeStr[i] as string;

    if (char === "{") {
      indent++;
      result += `{\n${INDENT.repeat(indent)}`;
    } else if (char === "}") {
      indent--;
      // Trim trailing whitespace/newlines before closing brace
      result = result.replace(/\s+$/, "");
      result += `\n${INDENT.repeat(indent)}}`;
    } else if (char === ";") {
      if (indent > 0) {
        result += `;\n${INDENT.repeat(indent)}`;
      } else {
        result += ";";
      }
    } else if (char === " " && result.endsWith("\n" + INDENT.repeat(indent))) {
      // Skip leading spaces after our indentation
      continue;
    } else {
      result += char;
    }
  }

  // Clean up any trailing whitespace on lines
  return result
    .split("\n")
    .map((line) => line.trimEnd())
    .join("\n");
}

const processedTypeString = formatTypeString(replaceAbsolutePaths(typeString));

// Validate: reject if the output references @features packages
if (processedTypeString.includes("@features/")) {
  throw new Error(
    "Generated type references @features/* — the type was not fully expanded. " +
      "This likely means a named type from a feature package leaked through. " +
      "Check that all feature types resolve to structural types.",
  );
}

// Write the generated file
fs.mkdirSync(OUTPUT_DIR, { recursive: true });

const header = [
  "// AUTO-GENERATED by apps/api gencode script — do not edit manually.",
  "// Run `pnpm gencode` from the repository root to regenerate.",
  "//",
  "// Generated from: apps/api/src/router.ts",
  "",
].join("\n");

const output = `${header}
export type Router = ${processedTypeString};
`;

fs.writeFileSync(OUTPUT_FILE, output);
console.log(`Generated: ${path.relative(path.resolve(API_ROOT, "../.."), OUTPUT_FILE)}`);
