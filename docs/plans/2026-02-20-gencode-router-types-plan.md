# Gencode Router Types Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Generate Router types into `@infrastructure/api-client` via a gencode script so apps never depend on `apps/api` for types.

**Architecture:** A TypeScript Compiler API script in `apps/api` serializes the `Router` type into a standalone `.d.ts` file in `@infrastructure/api-client/src/generated/`. Pre-typed client wrappers consume the generated type. Apps import from `@infrastructure/api-client` instead of `api/router`.

**Tech Stack:** TypeScript Compiler API, tsx, Turborepo gencode task, Vitest

---

### Task 1: Add Turbo Gencode Task and API Script Entry

**Files:**
- Modify: `turbo.json:4-28`
- Modify: `apps/api/package.json:14-18`

**Step 1: Add gencode task to turbo.json**

Add a `gencode` task to the `tasks` object in `turbo.json`. It has no dependsOn (it reads source directly) and outputs to the api-client generated directory:

```json
"gencode": {
  "cache": false
}
```

Place it after the `clean` task. Use `"cache": false` because the output goes to a different package's source directory (turbo can't track cross-package outputs properly).

**Step 2: Add gencode script to apps/api/package.json**

Add to the `scripts` object:

```json
"gencode": "tsx scripts/generate-router-types.ts"
```

**Step 3: Commit**

```bash
git add turbo.json apps/api/package.json
git commit -m "chore: add gencode turbo task and api script entry"
```

---

### Task 2: Write the Gencode Script

**Files:**
- Create: `apps/api/scripts/generate-router-types.ts`

**Step 1: Create the script**

Create `apps/api/scripts/generate-router-types.ts`:

```typescript
import * as fs from "node:fs";
import * as path from "node:path";
import * as ts from "typescript";

const API_ROOT = path.resolve(import.meta.dirname, "..");
const ROUTER_FILE = path.join(API_ROOT, "src/router.ts");
const OUTPUT_DIR = path.resolve(
  API_ROOT,
  "../../packages/infrastructure/api-client/src/generated",
);
const OUTPUT_FILE = path.join(OUTPUT_DIR, "router-types.d.ts");

// Load tsconfig for the api project
const configPath = ts.findConfigFile(API_ROOT, ts.sys.fileExists, "tsconfig.json");
if (!configPath) {
  throw new Error("Could not find apps/api/tsconfig.json");
}
const configFile = ts.readConfigFile(configPath, ts.sys.readFile);
const parsedConfig = ts.parseJsonConfigFileContent(configFile.config, ts.sys, API_ROOT);

// Create TypeScript program and type checker
const program = ts.createProgram([ROUTER_FILE], parsedConfig.options);
const checker = program.getTypeChecker();
const sourceFile = program.getSourceFile(ROUTER_FILE);

if (!sourceFile) {
  throw new Error(`Could not load source file: ${ROUTER_FILE}`);
}

// Find the Router type export
const moduleSymbol = checker.getSymbolAtLocation(sourceFile);
if (!moduleSymbol) {
  throw new Error("Could not get module symbol for router.ts");
}

const exports = checker.getExportsOfModule(moduleSymbol);
const routerExport = exports.find((e) => e.getName() === "Router");
if (!routerExport) {
  throw new Error('Could not find "Router" export in router.ts');
}

// Resolve the type behind the Router alias
const routerType = checker.getDeclaredTypeOfSymbol(routerExport);

// Serialize to a fully-expanded type string with no truncation
const typeString = checker.typeToString(
  routerType,
  sourceFile,
  ts.TypeFormatFlags.NoTruncation |
    ts.TypeFormatFlags.MultilineObjectLiterals |
    ts.TypeFormatFlags.InTypeAlias,
);

// Validate: reject if the output references @features packages
if (typeString.includes("@features/")) {
  throw new Error(
    "Generated type references @features/* — the type was not fully expanded. " +
      "This likely means a named type from a feature package leaked through. " +
      "Check that all feature types resolve to structural types.",
  );
}

// Write the generated file
fs.mkdirSync(OUTPUT_DIR, { recursive: true });

const header = [
  "// AUTO-GENERATED by apps/api gencode script — do not edit manually.",
  "// Run `pnpm gencode` from the repository root to regenerate.",
  "//",
  `// Generated from: apps/api/src/router.ts`,
  `// Generated at: ${new Date().toISOString()}`,
  "",
].join("\n");

const output = `${header}
export type Router = ${typeString};
`;

fs.writeFileSync(OUTPUT_FILE, output);
console.log(`Generated: ${path.relative(path.resolve(API_ROOT, "../.."), OUTPUT_FILE)}`);
```

**Key behaviors:**
- Uses the api project's own `tsconfig.json` so module resolution matches the build
- `getDeclaredTypeOfSymbol` resolves `type Router = typeof router` to the structural type
- `typeToString` with `NoTruncation | MultilineObjectLiterals | InTypeAlias` produces a readable, complete type
- Validation rejects output that still references `@features/*` (the type should be fully structural)
- References to `@orpc/server` and `zod` are expected and allowed (api-client depends on both)

**Step 2: Commit**

```bash
git add apps/api/scripts/generate-router-types.ts
git commit -m "feat: add gencode script for router type generation"
```

---

### Task 3: Run Gencode and Verify Output

**Step 1: Run the gencode script**

```bash
pnpm --filter api gencode
```

Expected: Script succeeds, prints the generated file path.

**Step 2: Verify the generated file exists**

```bash
cat packages/infrastructure/api-client/src/generated/router-types.d.ts
```

Expected: File contains `export type Router = { health: ...; users: { list: ...; get: ...; create: ...; }; };` with types referencing `@orpc/server` but NOT `@features/*`.

**Step 3: Verify TypeScript accepts the generated file**

```bash
pnpm --filter @infrastructure/api-client typecheck
```

Expected: No type errors.

**Step 4: If the generated type is not fully expanded**

If `typeToString` doesn't produce a standalone type (e.g., it still references feature packages), try these alternatives in the script:

1. Use `getTypeAtLocation` on the declaration node instead of `getDeclaredTypeOfSymbol`
2. Add `ts.TypeFormatFlags.UseStructuralFallback` to force structural expansion
3. Use `checker.typeToString(checker.getTypeOfSymbolAtLocation(routerExport, sourceFile.getChildAt(0)), ...)` to get the value type

**Step 5: Commit the generated file**

```bash
git add packages/infrastructure/api-client/src/generated/router-types.d.ts
git commit -m "chore: generate initial router types into api-client"
```

---

### Task 4: Typed Client (TDD)

**Files:**
- Create: `packages/infrastructure/api-client/src/__tests__/typed-client.test.ts`
- Create: `packages/infrastructure/api-client/src/typed-client.ts`
- Modify: `packages/infrastructure/api-client/src/index.ts`

**Step 1: Write the failing test**

Create `packages/infrastructure/api-client/src/__tests__/typed-client.test.ts`:

```typescript
import { describe, expect, it, vi } from "vitest";

vi.mock("@orpc/client", () => ({
  createORPCClient: vi.fn(() => ({ mocked: true })),
}));

vi.mock("@orpc/client/fetch", () => ({
  RPCLink: vi.fn(function (this: { options: { url: string } }, options: { url: string }) {
    this.options = options;
  }),
}));

vi.mock("@orpc/tanstack-query", () => ({
  createTanstackQueryUtils: vi.fn((client: unknown) => ({
    client,
    utils: true,
  })),
}));

import { createTypedApiClient, createTypedOrpcUtils } from "../typed-client";

describe("createTypedApiClient", () => {
  it("creates a pre-typed client for the given base URL", () => {
    const client = createTypedApiClient("http://localhost:3001/api");
    expect(client).toBeDefined();
  });
});

describe("createTypedOrpcUtils", () => {
  it("creates pre-typed tanstack query utils from a typed client", () => {
    const client = createTypedApiClient("http://localhost:3001/api");
    const utils = createTypedOrpcUtils(client);
    expect(utils).toBeDefined();
  });
});
```

Note: `RPCLink` mock uses a `function` expression (not arrow) because it's used as a constructor with `new` — Vitest 4 requires this per the CLAUDE.md gotcha.

**Step 2: Run the test to verify it fails**

```bash
pnpm --filter @infrastructure/api-client test
```

Expected: FAIL — `createTypedApiClient` and `createTypedOrpcUtils` not found (module doesn't exist yet).

**Step 3: Write the implementation**

Create `packages/infrastructure/api-client/src/typed-client.ts`:

```typescript
import type { RouterClient } from "@orpc/server";
import { createApiClient, createOrpcUtils } from "./client";
import type { Router } from "./generated/router-types";

/** Creates an API client pre-typed with the generated Router type. */
export function createTypedApiClient(baseUrl: string): RouterClient<Router> {
  return createApiClient<Router>(baseUrl);
}

/** Creates TanStack Query utils pre-typed with the generated Router type. */
export function createTypedOrpcUtils(client: RouterClient<Router>) {
  return createOrpcUtils(client);
}
```

**Step 4: Run the test to verify it passes**

```bash
pnpm --filter @infrastructure/api-client test
```

Expected: All tests PASS (both existing `client.test.ts` and new `typed-client.test.ts`).

**Step 5: Update the barrel export**

Modify `packages/infrastructure/api-client/src/index.ts`:

```typescript
export * from "./client";
export * from "./contract";
export * from "./typed-client";
export type { Router } from "./generated/router-types";
```

**Step 6: Verify typecheck still passes**

```bash
pnpm --filter @infrastructure/api-client typecheck
```

Expected: No type errors.

**Step 7: Commit**

```bash
git add packages/infrastructure/api-client/src/typed-client.ts \
       packages/infrastructure/api-client/src/__tests__/typed-client.test.ts \
       packages/infrastructure/api-client/src/index.ts
git commit -m "feat(api-client): add pre-typed client exports using generated Router type"
```

---

### Task 5: Migrate Apps

**Files:**
- Modify: `apps/web/lib/api.ts`
- Modify: `apps/web/package.json:16` (remove `"api": "workspace:*"`)
- Modify: `apps/mobile/lib/api.ts`
- Modify: `apps/mobile/package.json:22` (remove `"api": "workspace:*"`)

**Step 1: Migrate apps/web/lib/api.ts**

Replace the entire file contents with:

```typescript
import { createTypedApiClient, createTypedOrpcUtils } from "@infrastructure/api-client";

const API_URL = process.env.NEXT_PUBLIC_API_URL || "http://localhost:3001/api";

export const apiClient = createTypedApiClient(API_URL);
export const orpc = createTypedOrpcUtils(apiClient);
```

**Step 2: Remove `"api": "workspace:*"` from apps/web/package.json**

In the `dependencies` object, remove the line `"api": "workspace:*",`.

**Step 3: Migrate apps/mobile/lib/api.ts**

Replace the entire file contents with:

```typescript
import { createTypedApiClient, createTypedOrpcUtils } from "@infrastructure/api-client";
import Constants from "expo-constants";

const API_URL = Constants.expoConfig?.extra?.apiUrl || "http://localhost:3001/api";

export const apiClient = createTypedApiClient(API_URL);
export const orpc = createTypedOrpcUtils(apiClient);
```

**Step 4: Remove `"api": "workspace:*"` from apps/mobile/package.json**

In the `dependencies` object, remove the line `"api": "workspace:*",`.

**Step 5: Run pnpm install to update lockfile**

```bash
pnpm install
```

Expected: Lockfile updates to reflect removed api dependency from web and mobile.

**Step 6: Verify typecheck passes for both apps**

```bash
pnpm --filter web typecheck && pnpm --filter mobile typecheck
```

Expected: No type errors.

**Step 7: Run tests for affected packages**

```bash
pnpm --filter web test && pnpm --filter @infrastructure/api-client test
```

Expected: All tests pass.

**Step 8: Commit**

```bash
git add apps/web/lib/api.ts apps/web/package.json \
       apps/mobile/lib/api.ts apps/mobile/package.json \
       pnpm-lock.yaml
git commit -m "refactor: migrate apps to use pre-typed api-client, remove app-to-app dependency"
```

---

### Task 6: Update eng-constitution.md

**Files:**
- Modify: `eng-constitution.md:5-6` (Principle I)
- Modify: `eng-constitution.md:54-108` (Principle IX)

**Step 1: Update Principle I — add app isolation rule**

In Principle I (line 6), append after the existing text:

> Apps must never depend on other apps; type sharing between apps flows through infrastructure packages via code generation (`pnpm gencode`).

**Step 2: Update Principle IX — Client Usage Pattern**

Replace the Client Usage Pattern block (lines 100-108) with:

```typescript
// In consuming apps (web, mobile)
import { createTypedApiClient, createTypedOrpcUtils } from "@infrastructure/api-client";

const client = createTypedApiClient("http://localhost:3001/api");
const users = await client.users.list();
```

Add a note after the code block:

> Apps import pre-typed client utilities from `@infrastructure/api-client` — they never import types from `apps/api` directly. The `Router` type is generated into `@infrastructure/api-client` via `pnpm gencode` (see `apps/api/scripts/generate-router-types.ts`). After changing any router or contract, run `pnpm gencode` and commit the generated file.

**Step 3: Commit**

```bash
git add eng-constitution.md
git commit -m "docs(constitution): add app isolation rule and update oRPC client pattern"
```

---

### Task 7: Update CLAUDE.md

**Files:**
- Modify: `.claude/CLAUDE.md`

**Step 1: Add gencode to Commands section**

In the Commands bash block (after `pnpm gencode` line ~31), update the comment:

```bash
pnpm gencode          # Generate Router types from apps/api into @infrastructure/api-client
```

**Step 2: Update Architecture section — api-client description**

Change the `@infrastructure/api-client` line (~57) to:

```
  - `@infrastructure/api-client` — oRPC client utilities (`createApiClient`, `createTypedApiClient`), generated Router type, and shared base schemas
```

**Step 3: Update oRPC section**

Replace the oRPC section description (~68) with:

```
Feature packages own their contracts (`contracts/`) and routers (`routers/`). `apps/api` imports feature routers and composes the master router. `@infrastructure/api-client` provides both generic client utilities and pre-typed wrappers using a generated `Router` type. Apps import from `@infrastructure/api-client` — they never depend on `apps/api` directly. The `Router` type is generated via `pnpm gencode`. Query integration uses `@orpc/tanstack-query`.
```

Replace the consuming app code example (~90-96) with:

```typescript
// Consuming app (web/mobile)
import { createTypedApiClient, createTypedOrpcUtils } from "@infrastructure/api-client";
const client = createTypedApiClient("http://localhost:3001/api");
const orpc = createTypedOrpcUtils(client);
const { data } = useQuery(orpc.users.list.queryOptions());
```

**Step 4: Add gencode gotcha**

After the existing gotchas in the Dependencies section, add:

```
**Gotcha**: After changing any feature router or `apps/api/src/router.ts`, run `pnpm gencode` to regenerate the Router type in `@infrastructure/api-client`. The generated file (`packages/infrastructure/api-client/src/generated/router-types.d.ts`) must be committed — it is not regenerated during build or CI.
```

**Step 5: Commit**

```bash
git add .claude/CLAUDE.md
git commit -m "docs(claude-md): update oRPC pattern for gencode type generation"
```

---

### Task 8: Final Verification

**Step 1: Run full typecheck**

```bash
pnpm typecheck
```

Expected: All packages pass typecheck with no errors.

**Step 2: Run all tests**

```bash
pnpm test
```

Expected: All tests pass.

**Step 3: Run linter**

```bash
pnpm lint
```

Expected: No lint errors. If there are formatting issues in generated or modified files, run `pnpm lint:fix` and amend the relevant commit.

**Step 4: Verify the api dependency is truly gone**

```bash
grep -r '"api": "workspace:\*"' apps/web/package.json apps/mobile/package.json
```

Expected: No matches (dependency removed).

**Step 5: Verify generated file has no feature references**

```bash
grep "@features" packages/infrastructure/api-client/src/generated/router-types.d.ts
```

Expected: No matches.
